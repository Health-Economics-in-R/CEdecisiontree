[{"path":"/articles/build_tree.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Building a decision tree from components","text":"small decision trees simple directly write structure tree values. However, larger trees may become unwieldy error prone. can take advantage tree characteristics though: Sections tree may repeated particular unit cost health measure may used multiple edges Multiple trees may use cost health values Tree structure labeling may remain values assigned change e.g. sensitivity analysis alternative interventions Thus, can separate structure tree, labeling edges values assigned labels. way flexibility modify one better adhere DRY principle benefits offers. instance, can think value assignment like relational table key-value pairs key Label. decision tree tree cost values, edges labeled follows: joined values table:","code":""},{"path":"/articles/build_tree.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Building a decision tree from components","text":"Let us demonstrate approach using simple tree. First, define structure tree list format without additional information. Let’s make two-step binary tree. Now can add labels values tree. Define set cost, health values probabilities, independent tree structure. Next, assign cost, probability health labels particular branches. Finally, can pull together create single decision tree long format data frame. example may seem little -elaborate. demonstrates example components defined separately combined obtain single object input values. Alternatively, define label look table values look table outside R simply read join obtain equivalent object. data frame can now used main cost-effectiveness analysis. can run cost health analyses together.","code":"library(CEdecisiontree) library(dplyr) tree_struc <-   list(     '1' = c(2,3),     '2' = c(4,5),     '3' = c(6,7)) label_cost <-   list(     \"vaccinate\" = 10,     \"disease\" = 100)  label_probs <-    list(     \"vaccinate\" = 0.7,     \"vacc_disease\" = 0.1,     \"disease\" = 0.9)  label_health <-    list(     \"disease\" = 0.5) library(tibble)  cost_label_branch <-    tribble(~name,      ~from, ~to,           \"vaccinate\", 1,    2,           \"disease\",   2,    4,           \"disease\",   3,    6)  prob_label_branch <-    tribble(~name,      ~from, ~to,           \"vaccinate\",    1,  2,           \"vacc_disease\", 2,  4,           \"disease\",      3,  6)  health_label_branch <-    tribble(~name,     ~from, ~to,           \"disease\", 2,     4,           \"disease\", 3,     6) tree_dat <-   create_ce_tree_long_df(     tree_list = tree_struc,     label_probs = label_probs,     label_costs = label_cost,     label_health = label_health,     pname_from_to = prob_label_branch,     cname_from_to = cost_label_branch,     hname_from_to = health_label_branch)  tree_dat FALSE   from to name.cost cost    name.prob prob name.health health FALSE 1    1  2 vaccinate   10    vaccinate  0.7        <NA>     NA FALSE 2    1  3      <NA>   NA         <NA>  0.3        <NA>     NA FALSE 3    2  4   disease  100 vacc_disease  0.1     disease    0.5 FALSE 4    2  5      <NA>   NA         <NA>  0.9        <NA>     NA FALSE 5    3  6   disease  100      disease  0.9     disease    0.5 FALSE 6    3  7      <NA>   NA         <NA>  0.1        <NA>     NA library(reshape2)  label_branch_tab <- read.csv(here::here(\"data-raw/label-branch table.csv\")) label_branch_tab #>     unit        label from to #> 1   cost    vaccinate    1  2 #> 2   cost      disease    2  4 #> 3   cost      disease    3  6 #> 4   prob    vaccinate    1  2 #> 5   prob vacc_disease    2  4 #> 6   prob      disease    3  6 #> 7 health      disease    2  4 #> 8 health      disease    3  6  label_val_tab <- read.csv(here::here(\"data-raw/label-val table.csv\")) label_val_tab #>     unit        label   val #> 1   cost    vaccinate  10.0 #> 2   cost      disease 100.0 #> 3   prob    vaccinate   0.7 #> 4   prob vacc_disease   0.1 #> 5   prob      disease   0.9 #> 6 health      disease   0.5  tree_dat2 <-   create_ce_tree_df(label_branch_tab,                     label_val_tab,                     tree_struc) tree_dat2 #> # A tibble: 6 × 5 #>   from     to  cost health  prob #>   <chr> <dbl> <dbl>  <dbl> <dbl> #> 1 1         2    10   NA     0.7 #> 2 1         3    NA   NA     0.3 #> 3 2         4   100    0.5   0.1 #> 4 2         5    NA   NA     0.9 #> 5 3         6   100    0.5   0.9 #> 6 3         7    NA   NA     0.1 tree_costs <- tree_dat2 names(tree_costs)[names(tree_costs) == \"cost\"] <- \"vals\"  treemod <- define_model(dat_long = tree_costs) #> Removing column(s) health  dectree_expected_values(model = treemod) #> vals used for calculation. #>   1   2   3   4   5   6   7   8  #>  41  20  90 100   0 100   0   0 run_cedectree(tree_dat2) #> vals used for calculation. #> vals used for calculation. #> $cost #> $cost$ev_point #>   1   2   3   4   5   6   7   8  #>  41  20  90 100   0 100   0   0  #>  #> $cost$term_pop_point #> NULL #>  #>  #> $health #> $health$ev_point #>    1    2    3    4    5    6    7    8  #> 0.17 0.05 0.45 0.50 0.00 0.50 0.00 0.00  #>  #> $health$term_pop_point #> NULL"},{"path":"/articles/ce_analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A simple cost-effectiveness analysis","text":"Although CEdecisiontree package allows us calculations using different values separately, main purpose carry cost-effectiveness analyses. performed calling dectree() function cost health inputs using wrapper run_cedectree().","code":""},{"path":"/articles/ce_analysis.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"A simple cost-effectiveness analysis","text":"single outcome type function dectree() requires dataframe defining tree . Optionally, can also take PSA distributions probabilities values, PSA sample size n, list groups nodes state_list. returns expected values point estimates, PSA supplied. Also, pathway joint probabilities returned states provided. cost-effectiveness analysis including PSA","code":"library(CEdecisiontree) library(purrr) library(tibble) tree_dat <-    tribble(     ~from, ~to, ~vals, ~prob,      1,  2,   10,   0.7,      1,  3,   NA,   0.3,      2,  4,  100,   0.1,      2,  5,   NA,   0.9,      3,  6,  100,   0.9,      3,  7,   NA,   0.1) dectree(tree_dat,         state_list = list(all = c(4,5,6,7))) #> vals used for calculation. #> $ev_point #>   1   2   3   4   5   6   7   8  #>  41  20  90 100   0 100   0   0  #>  #> $term_pop_point #> $term_pop_point$all #> [1] 1 # run_cedectree(tree_dat)"},{"path":"/articles/comparison-with-other-packages.html","id":"comparison-with-heemod","dir":"Articles","previous_headings":"","what":"Comparison with heemod","title":"Comparison with other packages","text":"heemod package designed simulate general models let us perform analysis compare. First, need define transition matrix. essentially except heemod simulates predefined number iterations cycles need add final absorbing sink state (.e. \\(p_{ii} = 1\\)) associated costs. Define cost node: Finally, get expected cost £5600 100 cycles equivalent £5.6 previous analysis.","code":"library(heemod)  mat_base <- define_transition(   state_names = as.character(1:8),   0, 0.2, 0.8,0,0,0,0,0,    0,0,0, 0.2, 0.8,0,0,0,     0,0,0,0,0, 0.2, 0.8,0,   0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,1,   0,0,0,0,0,0,0,1 ) state_1 <- define_state(   cost_total = 0,   qaly = 0)  state_2 <- define_state(   cost_total = 10,   qaly = 1)  state_3 <- define_state(   cost_total = 1,   qaly = 1)  state_4 <- define_state(   cost_total = 10,   qaly = 1)  state_5 <- define_state(   cost_total = 1,   qaly = 1)  state_6 <- define_state(   cost_total = 10,   qaly = 1)  state_7 <- define_state(   cost_total = 1,   qaly = 1)  state_8 <- define_state(   cost_total = 0,   qaly = 0)  strat_base <- define_strategy(   transition = mat_base,   \"1\" = state_1,   \"2\" = state_2,   \"3\" = state_3,   \"4\" = state_4,   \"5\" = state_5,   \"6\" = state_6,   \"7\" = state_7,   \"8\" = state_8 ) run_model(   strat_base,   cycles = 100,   cost = cost_total,   effect = qaly) #> No named model -> generating names. #> 1 strategy run for 100 cycles. #>  #> Initial state counts: #>  #> 1 = 1000L #> 2 = 0L #> 3 = 0L #> 4 = 0L #> 5 = 0L #> 6 = 0L #> 7 = 0L #> 8 = 0L #>  #> Counting method: 'life-table'. #>  #>   #>  #> Counting method: 'beginning'. #>  #>   #>  #> Counting method: 'end'. #>  #> Values: #>  #>   cost_total qaly #> I       5600 2000"},{"path":"/articles/other-input-formats.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Using other input formats","text":"Quietly load libraries. Load example data package.","code":"library(CEdecisiontree) library(readr) library(dplyr) library(reshape2) library(tidyr) library(assertthat) data(\"cost\") data(\"probs\")"},{"path":"/articles/other-input-formats.html","id":"tree-structure","dir":"Articles","previous_headings":"","what":"Tree structure","title":"Using other input formats","text":"Generally, can specify tree children parent node. can compuationally efficient. can obtain list children probability matrix (structure defining transition matrix).","code":"tree <-  list(\"1\" = c(2,3),       \"2\" =  c(4,5),       \"3\" =  c(6,7),       \"4\" =  c(),       \"5\" =  c(),       \"6\" =  c(),       \"7\" =  c()) dat <-  data.frame(node = 1:7,             prob = c(NA, 0.2, 0.8, 0.2, 0.8, 0.2, 0.8),             vals = c(0,10,1,10,1,10,1)) tree #> $`1` #> [1] 2 3 #>  #> $`2` #> [1] 4 5 #>  #> $`3` #> [1] 6 7 #>  #> $`4` #> NULL #>  #> $`5` #> NULL #>  #> $`6` #> NULL #>  #> $`7` #> NULL dat #>   node prob vals #> 1    1   NA    0 #> 2    2  0.2   10 #> 3    3  0.8    1 #> 4    4  0.2   10 #> 5    5  0.8    1 #> 6    6  0.2   10 #> 7    7  0.8    1  dectree_expected_recursive(names(tree)[1], tree, dat) #> [1] 5.6 transmat_to_child_list(probs) #> $`1` #> [1] 2 3 #>  #> $`2` #> [1] 4 5 #>  #> $`3` #> [1] 6 7 #>  #> $`4` #> integer(0) #>  #> $`5` #> integer(0) #>  #> $`6` #> integer(0) #>  #> $`7` #> integer(0)"},{"path":"/articles/other-input-formats.html","id":"single-long-array","dir":"Articles","previous_headings":"","what":"Single long array","title":"Using other input formats","text":"keep flat arrays clearly, size tree increased sparse matrices become impractical. can provide long format array address . Let us transform wide array used previously demonstrate structure space saving. can use long array input argument instead separate transition matrices. Internally, simple convert back matrix using long_to_transmat() larger trees may inefficient.","code":"probs_long <-   probs %>%   mutate('from' = rownames(.)) %>%   melt(id.vars = \"from\",        variable.name = 'to',        value.name = 'prob') %>%   mutate(to = as.numeric(to)) %>%    na.omit()  cost_long <-   cost %>%   mutate('from' = rownames(.)) %>%   melt(id.vars = \"from\",        variable.name = 'to',        value.name = 'vals') %>%   mutate(to = as.numeric(to)) %>%    na.omit()  dat_long <-   merge(probs_long,         cost_long)  dat_long #>   from to prob vals #> 1    1  2  0.2   10 #> 2    1  3  0.8    1 #> 3    2  4  0.2   10 #> 4    2  5  0.8    1 #> 5    3  6  0.2   10 #> 6    3  7  0.8    1 dectree_expected_values(   define_model(dat_long = dat_long)) #> vals used for calculation. #>    1    2    3    4    5    6    7    8  #>  5.6 12.8  3.8 10.0  1.0 10.0  1.0  0.0"},{"path":"/articles/other-input-formats.html","id":"computation-speed","dir":"Articles","previous_headings":"","what":"Computation speed","title":"Using other input formats","text":"can compare computation times recursive non-recursive formulations. example recursive formulation much quicker. Change memory running functions.","code":"microbenchmark::microbenchmark(dectree_expected_values(define_model(dat_long = dat_long)),                                dectree_expected_recursive(names(tree)[1], tree, dat), times = 100L) #> Unit: microseconds #>                                                        expr     min       lq #>  dectree_expected_values(define_model(dat_long = dat_long)) 11565.9 11931.40 #>       dectree_expected_recursive(names(tree)[1], tree, dat)    27.5    28.95 #>       mean   median       uq     max neval cld #>  12966.286 12500.65 13496.80 20457.3   100   b #>     37.739    41.70    44.15    62.4   100  a pryr::mem_change(dectree_expected_values(  define_model(dat_long = dat_long))) #> vals used for calculation. #> -3.69 kB pryr::mem_change(dectree_expected_recursive(names(tree)[1], tree, dat)) #> 528 B"},{"path":"/articles/probability-sensitivity-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Probability Sensitivity Analysis (PSA)","text":"PSA core part cost-effectiveness analysis (Briggs et al. 2012). carry simple decision tree. involves repeatedly sampling distribution branch probability cost calculating total expected value set realisations.","code":""},{"path":"/articles/probability-sensitivity-analysis.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Probability Sensitivity Analysis (PSA)","text":"first define decision tree. difference previous trees now use list-column feature define distributions rather point values. can now loop tree generate samples values given distributions. use sample_distributions() function treeSimR package. wrapped convenience function create_psa_inputs. results list trees. Now straightforward map trees obtain total expected values","code":"library(CEdecisiontree, quietly = TRUE) library(assertthat, quietly = TRUE) library(treeSimR, quietly = TRUE) library(tibble, quietly = TRUE) library(tidyverse, quietly = TRUE) library(purrr, quietly = TRUE) tree_dat <-   list(child = list(\"1\" = c(2, 3),                     \"2\" = NULL,                     \"3\" = NULL),        dat = tibble(          node = 1:3,          prob =            list(              NA_real_,              list(distn = \"unif\", params = c(min = 0, max = 1)),              list(distn = \"unif\", params = c(min = 0, max = 1))),          vals =            list(              0L,              list(distn = \"unif\", params = c(min = 0, max = 1)),              list(distn = \"unif\", params = c(min = 0, max = 1)))))  tree_dat #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #> # A tibble: 3 × 3 #>    node prob             vals             #>   <int> <list>           <list>           #> 1     1 <dbl [1]>        <int [1]>        #> 2     2 <named list [2]> <named list [2]> #> 3     3 <named list [2]> <named list [2]> library(purrr)  tree_dat_sa <- create_psa_inputs(tree_dat, n = 1000) head(tree_dat_sa, 2) #> [[1]] #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #>   node      prob      vals #> 1    1        NA 0.0000000 #> 2    2 0.9626497 0.2399404 #> 3    3 0.5228080 0.3990208 #>  #> attr(,\"class\") #> [1] \"tree_dat\" \"list\"     #>  #> [[2]] #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #>   node       prob       vals #> 1    1         NA 0.00000000 #> 2    2 0.91564742 0.47827629 #> 3    3 0.03897943 0.02314612 #>  #> attr(,\"class\") #> [1] \"tree_dat\" \"list\" res <- map_dbl(tree_dat_sa, dectree_expected_values) head(res) #> [1] 0.4395898 0.4388347 0.9441533 0.6099253 0.5126502 0.4441804   hist(res, breaks = 20)"},{"path":[]},{"path":"/articles/scenario-sensitivity-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Scenario Sensitivity Analysis","text":"Scenario (deterministic) sensitivity analysis common part cost-effectiveness analysis [@Briggs2012]. carry simple decision tree. involves explicitly specifying values particular branch probability /values calculating total expected value.","code":""},{"path":"/articles/scenario-sensitivity-analysis.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Scenario Sensitivity Analysis","text":"create complete design meaning combinations grid input values. Alternatively, may want one-way analysis set non-varied term common baseline distribution fixed value. example, choose three values parameter. can think worst-, likely best-case scenario. define decision tree structure just basic binary tree. can now loop inputs generate complete tree object cost combination. results list trees. Now, straightforward map trees obtain total expected values.","code":"library(CEdecisiontree, quietly = TRUE) library(assertthat, quietly = TRUE) library(treeSimR, quietly = TRUE) library(tibble, quietly = TRUE) library(tidyverse, quietly = TRUE) library(purrr, quietly = TRUE) p <- c(NA_real_, 0.4, 0.6)  c2 <- c(10, 50, 100) c3 <- c(5, 40, 150)  c_grid <-   expand.grid(c2 = c2,               c3 = c3) %>%    cbind(c1 = 0L, .) %>%    t() %>%    as.data.frame()  c_grid #>    V1 V2  V3 V4 V5  V6  V7  V8  V9 #> c1  0  0   0  0  0   0   0   0   0 #> c2 10 50 100 10 50 100  10  50 100 #> c3  5  5   5 40 40  40 150 150 150 child <- list(\"1\" = c(2, 3),               \"2\" = NULL,               \"3\" = NULL) tree_dat_sa <- list()  for (i in seq_along(c_grid)) {      tree_dat_sa[[i]] <-     define_model(       tree_dat =         list(child = child,              dat = data.frame(                node = names(child),                prob = p,                vals = c_grid[[i]])         )) } tree_dat_sa[[1]] #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #>   node prob vals #> 1    1   NA    0 #> 2    2  0.4   10 #> 3    3  0.6    5 #>  #> attr(,\"class\") #> [1] \"tree_dat\" \"list\" res <- map_dbl(tree_dat_sa, dectree_expected_values) res #> [1]   7  23  43  28  44  64  94 110 130"},{"path":"/articles/scenario-sensitivity-analysis.html","id":"tornado-plot","dir":"Articles","previous_headings":"Example","what":"Tornado plot","title":"Scenario Sensitivity Analysis","text":"Lets create tornado plot showing one-way sensitivity analysis. ’ll use ceplot. specifying output data model frame handled appropriately.","code":"library(ceplot) library(reshape2) library(magrittr) library(plyr) library(purrr) library(dplyr) library(ggplot2)  sa_dat <- as.data.frame(cbind(t(c_grid), res))  sa_model_dat <- model.frame(formula = res ~ c1 + c2 + c3,                             data = sa_dat)  ##TODO: ceplot package build error # sa_model_dat %>% #   ceplot::create_tornado_data() %>% #   ceplot::ggplot_tornado()"},{"path":"/articles/Using_function_dispatch.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Using function dispatch","text":"far, passed particular data formats dectree_expected_values, need explicit arguments associated . Alternatively, can define model upfront pass object dectree_expected_values dispatch appropriate function using S3.","code":""},{"path":"/articles/Using_function_dispatch.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Using function dispatch","text":"Let us create 3 input variables, line 3 formats met already, using define_model function. Now simply case passing main function call.","code":"library(CEdecisiontree) library(dplyr) library(assertthat) model_transmat <-    define_model(transmat =                  list(prob = matrix(data = c(NA, 0.5, 0.5), nrow = 1),                       vals = matrix(data = c(NA, 1, 2), nrow = 1)                  )) model_transmat #> $prob #>      [,1] [,2] [,3] #> [1,]   NA  0.5  0.5 #>  #> $vals #>      [,1] [,2] [,3] #> [1,]   NA    1    2 #>  #> attr(,\"class\") #> [1] \"transmat\" \"list\"  model_tree <-    define_model(tree_dat =                  list(child = list(\"1\" = c(2, 3),                                    \"2\" = NULL,                                    \"3\" = NULL),                       dat = data.frame(node = 1:3,                                        prob = c(NA, 0.5, 0.5),                                        vals = c(0, 1, 2))                  )) model_tree #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #>   node prob vals #> 1    1   NA    0 #> 2    2  0.5    1 #> 3    3  0.5    2 #>  #> attr(,\"class\") #> [1] \"tree_dat\" \"list\"  model_long <-    define_model(dat_long = data.frame(from = c(NA,1, 1),                                      to = c(1, 2, 3),                                      prob = c(NA, 0.5, 0.5),                                      vals = c(0, 1, 2))) model_long #>   from to prob vals #> 1   NA  1   NA    0 #> 2    1  2  0.5    1 #> 3    1  3  0.5    2 #> 4    2  4   NA    0 #> 5    3  4   NA    0 dectree_expected_values(model_transmat) #> [1] 1.5 1.0 2.0 dectree_expected_values(model_tree) #> [1] 1.5 dectree_expected_values(model_long) #> vals used for calculation. #>   1   2   3   4  #> 1.5 1.0 2.0 0.0"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Nathan Green. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Green N (2022). CEdecisiontree: Cost-effectiveness decision tree analysis. R package version 0.1.0.","code":"@Manual{,   title = {CEdecisiontree: Cost-effectiveness decision tree analysis},   author = {Nathan Green},   year = {2022},   note = {R package version 0.1.0}, }"},{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement [INSERT CONTACT METHOD]. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.0, available https://www.contributor-covenant.org/version/2/0/code_of_conduct.html. Community Impact Guidelines inspired Mozilla’s code conduct enforcement ladder. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https:// www.contributor-covenant.org/translations.","code":""},{"path":"/index.html","id":"cedecisiontree-","dir":"","previous_headings":"","what":"Cost-effectiveness decision tree analysis","title":"Cost-effectiveness decision tree analysis","text":"R package lightweight cost-effectiveness analysis using decision trees. Requests comments welcome; please use Issues.","code":""},{"path":"/index.html","id":"installing-cedecisiontree","dir":"","previous_headings":"","what":"Installing CEdecisiontree","title":"Cost-effectiveness decision tree analysis","text":"install development version github: , load package, use:","code":"library(remotes) install_github(\"Health-Economics-in-R/CEdecisiontree\") library(CEdecisiontree)"},{"path":"/index.html","id":"motivation","dir":"","previous_headings":"","what":"Motivation","title":"Cost-effectiveness decision tree analysis","text":"Decisions trees can modelled special cases general models using available packages R e.g. heemod, mstate msm. , full probability models fit using Bayesian model e.g. Stan, jags WinBUGS. However, simple decision tree models often built Excel, using statistics literature expert knowledge. package analogue , models can specified similar simple way.","code":""},{"path":"/index.html","id":"calculation","dir":"","previous_headings":"","what":"Calculation","title":"Cost-effectiveness decision tree analysis","text":"decision tree defined parent-child pairs, .e. -connections, probability associated value (e.g. cost) traversing connections. Denote probability transitioning node    cost attributable node  . connection exists two nodes shall say parent’s set children empty set . Denote set children . Clearly,   case computational purposes assume  . expected value node  calculated ‘folding back’ using recursive formula  boundary values terminal nodes","code":""},{"path":"/index.html","id":"basic-example","dir":"","previous_headings":"","what":"Basic example","title":"Cost-effectiveness decision tree analysis","text":"Quietly load libraries. consider simple 7 node binary tree. Numeric labels shown node. Probabilities costs show branch, respectively.  write expected cost full give  Load example data package. cost probability matrices use example sparse arrays indicating edge values (rows=node, columns=node). therefore dimensions entry pattern. Empty cells NA. probs probability transition matrix. like pmatrix.msm msm package, define_transition heemod package. transMat() function mstate package creates closely related multi-state model transition matrix. Copying package, can create decision tree transition matrix use . expected value node calculate follows. also Rcpp version function.","code":"library(CEdecisiontree) library(readr) library(dplyr) library(reshape2) library(tidyr) library(assertthat) data(\"cost\") data(\"probs\") cost #> # A tibble: 3 × 7 #>     `1`   `2`   `3`   `4`   `5`   `6`   `7` #>   <dbl> <int> <int> <int> <int> <int> <int> #> 1    NA    10     1    NA    NA    NA    NA #> 2    NA    NA    NA    10     1    NA    NA #> 3    NA    NA    NA    NA    NA    10     1 probs #> # A tibble: 3 × 7 #>     `1`   `2`   `3`   `4`   `5`   `6`   `7` #>   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1    NA   0.2   0.8  NA    NA    NA    NA   #> 2    NA  NA    NA     0.2   0.8  NA    NA   #> 3    NA  NA    NA    NA    NA     0.2   0.8 CEdecisiontree:::trans_binarytree(depth = 3) #>     to #> from  1  2  3  4  5  6  7 #>    1 NA  1  2 NA NA NA NA #>    2 NA NA NA  3  4 NA NA #>    3 NA NA NA NA NA  5  6 my_model <-   define_model(     transmat = list(vals = cost,                     prob = probs))  dectree_expected_values(model = my_model) #>    1    2    3    4    5    6    7  #>  5.6 12.8  3.8 10.0  1.0 10.0  1.0 Cdectree_expected_values(vals = as.matrix(cost),                          p = as.matrix(probs))"},{"path":"/index.html","id":"other-tree-statistics","dir":"","previous_headings":"","what":"Other tree statistics","title":"Cost-effectiveness decision tree analysis","text":"additional information, including purposes model checking can calculate tree statistics. can obtain contributing cost weighted chance occurrence. can thought trade-raw, original cost branch position. can check sums total expected cost. can also calculate joint probabilities traversing terminal state using branch_joint_probs. useful alternative model set-used total costs health values assigned terminal nodes . assume node labelling order root terminal nodes last. See package vignettes details examples.","code":"wcost <- branch_joint_probs(my_model) * cost wcost #>    1  2   3   4    5   6    7 #> 1 NA  2 0.8  NA   NA  NA   NA #> 2 NA NA  NA 0.4 0.16  NA   NA #> 3 NA NA  NA  NA   NA 1.6 0.64 sum(wcost, na.rm = TRUE) #> [1] 5.6 n_from_nodes <- nrow(probs) n_to_nodes <- ncol(probs) terminal_states <- (n_from_nodes + 1):n_to_nodes  p_terminal_state <-   branch_joint_probs(my_model)[ ,terminal_states] %>%   colSums(na.rm = TRUE)  p_terminal_state #>    4    5    6    7  #> 0.04 0.16 0.16 0.64 sum(p_terminal_state) #> [1] 1"},{"path":"/index.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Cost-effectiveness decision tree analysis","text":"Please note CEdecisiontree project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":[]},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2019 Nathan Green Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/reference/bcg_cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Costs in transition matrix format — bcg_cost","title":"Costs in transition matrix format — bcg_cost","text":"Costs transition matrix format","code":""},{"path":"/reference/bcg_cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Costs in transition matrix format — bcg_cost","text":"","code":"bcg_cost"},{"path":"/reference/bcg_cost.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Costs in transition matrix format — bcg_cost","text":"7--15 matrix rows state columns state","code":""},{"path":"/reference/bcg_probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Probabilities in transition matrix format — bcg_probs","title":"Probabilities in transition matrix format — bcg_probs","text":"Probabilities transition matrix format","code":""},{"path":"/reference/bcg_probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probabilities in transition matrix format — bcg_probs","text":"","code":"bcg_probs"},{"path":"/reference/bcg_probs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Probabilities in transition matrix format — bcg_probs","text":"7--15 matrix rows state columns state","code":""},{"path":"/reference/bcg_utility.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility in transition matrix format — bcg_utility","title":"Utility in transition matrix format — bcg_utility","text":"Utility transition matrix format","code":""},{"path":"/reference/bcg_utility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility in transition matrix format — bcg_utility","text":"","code":"bcg_utility"},{"path":"/reference/bcg_utility.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Utility in transition matrix format — bcg_utility","text":"7--15 matrix rows state columns state","code":""},{"path":"/reference/branch_joint_probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Branch Joint Probabilities — branch_joint_probs","title":"Branch Joint Probabilities — branch_joint_probs","text":"Provides measure chances following particular paths decision tree.","code":""},{"path":"/reference/branch_joint_probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Branch Joint Probabilities — branch_joint_probs","text":"","code":"branch_joint_probs(model, ...)  # S3 method for transmat branch_joint_probs(model, nodes = NA, ...)  # S3 method for dat_long branch_joint_probs(model, nodes, ...)  # S3 method for default branch_joint_probs(model, nodes, ...)"},{"path":"/reference/branch_joint_probs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Branch Joint Probabilities — branch_joint_probs","text":"model Branch conditional probabilities (matrix) ... Additional parameters nodes nodes return; default ","code":""},{"path":"/reference/branch_joint_probs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Branch Joint Probabilities — branch_joint_probs","text":"Transition matrix joint probabilities","code":""},{"path":"/reference/branch_joint_probs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Branch Joint Probabilities — branch_joint_probs","text":"probabilities used weight branch costs QALYs indicate relative contribution total expected value.","code":""},{"path":"/reference/branch_joint_probs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Branch Joint Probabilities — branch_joint_probs","text":"","code":"model <-   define_model(     transmat =       list(prob =              matrix(data = c(NA, 0.5, 0.5, NA,  NA,  NA,  NA,                              NA, NA, NA,   0.1, 0.9, NA,  NA,                              NA, NA, NA,   NA,  NA,  0.9, 0.1),                     nrow = 3,                     byrow = TRUE),            vals =              matrix(data = c(NA, 1,  5,  NA, NA, NA, NA,                              NA, NA, NA, 1,  9,  NA, NA,                              NA, NA, NA, NA, NA, 9,  1),                     nrow = 3,                     byrow = TRUE))) model #> $prob #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]   NA  0.5  0.5   NA   NA   NA   NA #> [2,]   NA   NA   NA  0.1  0.9   NA   NA #> [3,]   NA   NA   NA   NA   NA  0.9  0.1 #>  #> $vals #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]   NA    1    5   NA   NA   NA   NA #> [2,]   NA   NA   NA    1    9   NA   NA #> [3,]   NA   NA   NA   NA   NA    9    1 #>  #> attr(,\"class\") #> [1] \"transmat\" \"list\"      branch_joint_probs(model) #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]   NA  0.5  0.5   NA   NA   NA   NA #> [2,]   NA   NA   NA 0.05 0.45   NA   NA #> [3,]   NA   NA   NA   NA   NA 0.45 0.05  # weighted vals branch_joint_probs(model)*model$vals #>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] #> [1,]   NA  0.5  2.5   NA   NA   NA   NA #> [2,]   NA   NA   NA 0.05 4.05   NA   NA #> [3,]   NA   NA   NA   NA   NA 4.05 0.05  # long data format df <-   data.frame(     from = c(1,2,1),     to = c(2,3,4),     prob = c(0.1,0.5,0.9),     vals = c(1,2,3))  mod <- define_model(dat_long = df)  branch_joint_probs(mod, nodes = 4) #> [[1]] #> [1] 1.0 0.9 #>  #0.9  branch_joint_probs(mod, nodes = 3) #> [[1]] #> [1] 1.0 0.5 0.1 #>  #0.1*0.5  branch_joint_probs(mod, nodes = 3)[[1]] |> cumprod() #> [1] 1.00 0.50 0.05"},{"path":"/reference/Cdectree_expected_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Cdectree_expected_values — Cdectree_expected_values","title":"Cdectree_expected_values — Cdectree_expected_values","text":"Cdectree_expected_values","code":""},{"path":"/reference/Cdectree_expected_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cdectree_expected_values — Cdectree_expected_values","text":"","code":"Cdectree_expected_values(vals, p)"},{"path":"/reference/Cdectree_expected_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cdectree_expected_values — Cdectree_expected_values","text":"vals Values p Probabilities","code":""},{"path":"/reference/child_list_to_transmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Create transition matrix from tree children list — child_list_to_transmat","title":"Create transition matrix from tree children list — child_list_to_transmat","text":"Create transition matrix tree children list parents.","code":""},{"path":"/reference/child_list_to_transmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create transition matrix from tree children list — child_list_to_transmat","text":"","code":"child_list_to_transmat(tree)"},{"path":"/reference/child_list_to_transmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create transition matrix from tree children list — child_list_to_transmat","text":"tree parent-child node list.","code":""},{"path":"/reference/child_list_to_transmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create transition matrix from tree children list — child_list_to_transmat","text":"matrix","code":""},{"path":"/reference/child_list_to_transmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create transition matrix from tree children list — child_list_to_transmat","text":"","code":"child_list_to_transmat(tree =                          list('1' = c(2, 3),                               '2' = c(4),                               '3' = c(6, 7))) #>    1   2   3  4  5   6   7 #> 1 NA 0.5 0.5 NA NA  NA  NA #> 2 NA  NA  NA  1 NA  NA  NA #> 3 NA  NA  NA NA NA 0.5 0.5 #> 4 NA  NA  NA NA NA  NA  NA #> 5 NA  NA  NA NA NA  NA  NA #> 6 NA  NA  NA NA NA  NA  NA #> 7 NA  NA  NA NA NA  NA  NA"},{"path":"/reference/cost.html","id":null,"dir":"Reference","previous_headings":"","what":"Costs in transition matrix format — cost","title":"Costs in transition matrix format — cost","text":"Costs transition matrix format","code":""},{"path":"/reference/cost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Costs in transition matrix format — cost","text":"","code":"cost"},{"path":"/reference/cost.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Costs in transition matrix format — cost","text":"3--7 matrix rows state columns state","code":""},{"path":"/reference/create_ce_tree_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create cost-effectiveness decision tree data frame input — create_ce_tree_df","title":"Create cost-effectiveness decision tree data frame input — create_ce_tree_df","text":"Using look table, rather separate lists, values labels. Can prepare external R read .","code":""},{"path":"/reference/create_ce_tree_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create cost-effectiveness decision tree data frame input — create_ce_tree_df","text":"","code":"create_ce_tree_df(label_branch_tab, label_val_tab, tree_struc)"},{"path":"/reference/create_ce_tree_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create cost-effectiveness decision tree data frame input — create_ce_tree_df","text":"label_branch_tab Look table label_val_tab Look table tree_struc List parent child branches","code":""},{"path":"/reference/create_ce_tree_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create cost-effectiveness decision tree data frame input — create_ce_tree_df","text":"tibble long format","code":""},{"path":"/reference/create_ce_tree_long_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Cost-Effectiveness Tree For Long Dataframe — create_ce_tree_long_df","title":"Create Cost-Effectiveness Tree For Long Dataframe — create_ce_tree_long_df","text":"Completely specifying cost-effectiveness decision tree. Matches labels branches corresponding probabilities cost/utility values.","code":""},{"path":"/reference/create_ce_tree_long_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Cost-Effectiveness Tree For Long Dataframe — create_ce_tree_long_df","text":"","code":"create_ce_tree_long_df(   tree_list = NA,   tree_mat = NA,   label_probs,   label_costs,   label_health,   pname_from_to,   cname_from_to,   hname_from_to )"},{"path":"/reference/create_ce_tree_long_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Cost-Effectiveness Tree For Long Dataframe — create_ce_tree_long_df","text":"tree_list Parent-child ids format tree_mat Matrix format label_probs List label_costs List label_health Health labels pname_from_to Dataframe name, , cname_from_to Dataframe name, , hname_from_to Health names -edges","code":""},{"path":"/reference/create_ce_tree_long_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Cost-Effectiveness Tree For Long Dataframe — create_ce_tree_long_df","text":"Long format dataframe input `define_model()`         `dectree()`. Note single edge value         type (e.g. cost QALY). Use `run_cedectree()`         cost health.","code":""},{"path":[]},{"path":"/reference/create_psa_inputs.html","id":null,"dir":"Reference","previous_headings":"","what":"Create PSA inputs — create_psa_inputs","title":"Create PSA inputs — create_psa_inputs","text":"Create PSA inputs","code":""},{"path":"/reference/create_psa_inputs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create PSA inputs — create_psa_inputs","text":"","code":"create_psa_inputs(tree_dat, n = 1000)"},{"path":"/reference/create_psa_inputs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create PSA inputs — create_psa_inputs","text":"tree_dat parent-child data format distributions n Number samples","code":""},{"path":"/reference/create_psa_inputs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create PSA inputs — create_psa_inputs","text":"tree_dat realisations","code":""},{"path":"/reference/dectree.html","id":null,"dir":"Reference","previous_headings":"","what":"Decision tree estimation — dectree","title":"Decision tree estimation — dectree","text":"Single edge value (e.g. cost QALY) wrapper.","code":""},{"path":"/reference/dectree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Decision tree estimation — dectree","text":"","code":"dectree(   dat_long,   label_probs_distns = NULL,   label_vals_distns = NULL,   state_list = NULL,   vals_col = NA,   n = 100 )"},{"path":"/reference/dectree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Decision tree estimation — dectree","text":"dat_long Long format data frame , , prob, vals columns. label_probs_distns Probability distribution names label_vals_distns Value distribution names state_list State list sets, usually terminal nodes vals_col Name values column; defaults vals n Number PSA samples; default 100","code":""},{"path":"/reference/dectree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Decision tree estimation — dectree","text":"List expected values node,         joint probabilities terminal state set         PSA samples distributions provided.","code":""},{"path":"/reference/dectree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Decision tree estimation — dectree","text":"","code":"library(purrr) library(tibble)  dat_long <-  tribble(    ~from, ~to, ~vals, ~prob,    1,  2,   10,   0.7,    1,  3,   NA,   0.3,    2,  4,  100,   0.1,    2,  5,   NA,   0.9,    3,  6,  100,   0.9,    3,  7,   NA,   0.1)  dectree(dat_long,    state_list = list(all = c(4,5,6,7))) #> vals used for calculation. #> $ev_point #>   1   2   3   4   5   6   7   8  #>  41  20  90 100   0 100   0   0  #>  #> $term_pop_point #> $term_pop_point$all #> [1] 1 #>  #>"},{"path":"/reference/dectree_expected_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Cost-effectiveness decision tree expected values — dectree_expected_default","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"Root node expected value weighted mean probability edge/node values e.g. costs QALYS.","code":""},{"path":"/reference/dectree_expected_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"","code":"dectree_expected_default(vals, p, dat = NA)"},{"path":"/reference/dectree_expected_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"vals Values edge/branch e.g. costs QALYs (array) p Transition probabilities matrix dat Long node-edge value array; default: NA","code":""},{"path":"/reference/dectree_expected_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"Expected value node (vector)","code":""},{"path":"/reference/dectree_expected_default.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"expected value node calculate $$\\hat{c}_i = c_i + \\sum p_{ij} \\hat{c}_j$$ default calculation assumes costs associated nodes. alternative associate edges. total expected cost matter nodes different assuming costs assigned nodes. expected value $$\\hat{c}_i = \\sum p_{ij} (c_{ij} + \\hat{c}_j)$$","code":""},{"path":"/reference/dectree_expected_default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cost-effectiveness decision tree expected values — dectree_expected_default","text":"","code":"# dectree_expected_default(vals, p)"},{"path":"/reference/dectree_expected_recursive.html","id":null,"dir":"Reference","previous_headings":"","what":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","title":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","text":"Cost-effectiveness decision tree using recursive approach","code":""},{"path":"/reference/dectree_expected_recursive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","text":"","code":"dectree_expected_recursive(node, tree, dat)"},{"path":"/reference/dectree_expected_recursive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","text":"node Node total expected value calculate tree List children parents dat Node labels, branch probabilities value; data frame","code":""},{"path":"/reference/dectree_expected_recursive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","text":"Expected value root node","code":""},{"path":[]},{"path":"/reference/dectree_expected_recursive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cost-effectiveness decision tree using recursive approach — dectree_expected_recursive","text":"","code":"tree <-   list(\"1\" = c(2,3),        \"2\" =  c(4,5),        \"3\" =  c(6,7),        \"4\" =  c(),        \"5\" =  c(),        \"6\" =  c(),        \"7\" =  c()) dat <-   data.frame(node = 1:7,              prob = c(NA, rep(0.5, 6)),              vals = c(10,2,3,16,5,6,7))  root <- names(tree)[1] dectree_expected_recursive(node = root, tree, dat) #> [1] 21"},{"path":"/reference/dectree_expected_recursive2.html","id":null,"dir":"Reference","previous_headings":"","what":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","title":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","text":"Cost-effectiveness decision tree using recursive approach 2 child nodes","code":""},{"path":"/reference/dectree_expected_recursive2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","text":"","code":"dectree_expected_recursive2(node, tree, dat)"},{"path":"/reference/dectree_expected_recursive2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","text":"node Node total expected value calculate tree List children parents dat Node labels, branch probabilities value; data frame","code":""},{"path":"/reference/dectree_expected_recursive2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","text":"Expected value root node","code":""},{"path":[]},{"path":"/reference/dectree_expected_recursive2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cost-effectiveness decision tree using recursive approach for more than 2 child nodes — dectree_expected_recursive2","text":"","code":"tree <-   list(\"1\" = c(2,3,5),        \"2\" =  4,        \"3\" =  c(6,7),        \"4\" =  c(),        \"5\" =  c(),        \"6\" =  c(),        \"7\" =  c()) dat <-   data.frame(node = 1:7,              prob = c(NA, rep(1, 6)),              vals = c(10,2,3,16,5,6,7))  root <- names(tree)[1] dectree_expected_recursive2(node = root, tree, dat) #> [1] 49"},{"path":"/reference/dectree_expected_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Cost-effectiveness decision tree expected values — dectree_expected_values","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"Root node expected value weighted mean probability edge/node values e.g. costs QALYS.","code":""},{"path":"/reference/dectree_expected_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"","code":"dectree_expected_values(model, ...)  # S3 method for tree_dat dectree_expected_values(model, ...)  # S3 method for transmat dectree_expected_values(model, ...)  # S3 method for dat_long dectree_expected_values(model, ...)"},{"path":"/reference/dectree_expected_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"model Object define_model() consisting output type tree_dat, transmat dat_long ... Additional parameters","code":""},{"path":"/reference/dectree_expected_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"Expected value node","code":""},{"path":"/reference/dectree_expected_values.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"expected value node calculate $$\\hat{c}_i = c_i + \\sum p_{ij} \\hat{c}_j$$ default calculation assumes costs associated nodes. alternative associate edges. total expected cost matter nodes different assuming costs assigned nodes. expected value $$\\hat{c}_i = \\sum p_{ij} (c_{ij} + \\hat{c}_j)$$","code":""},{"path":[]},{"path":"/reference/dectree_expected_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cost-effectiveness decision tree expected values — dectree_expected_values","text":"","code":"data(\"cost\") data(\"probs\")  my_model <-   define_model(     transmat = list(vals = cost,                     prob = probs))  dectree_expected_values(model = my_model) #>    1    2    3    4    5    6    7  #>  5.6 12.8  3.8 10.0  1.0 10.0  1.0"},{"path":"/reference/define_model.html","id":null,"dir":"Reference","previous_headings":"","what":"Define decision tree model — define_model","title":"Define decision tree model — define_model","text":"Basic constructor decision tree classes different data formats.","code":""},{"path":"/reference/define_model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define decision tree model — define_model","text":"","code":"define_model(transmat, tree_dat, dat_long, ...)"},{"path":"/reference/define_model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define decision tree model — define_model","text":"transmat Transition probability matrix. Rows nodes columns nodes. tree_dat Hierarchical tree structure parents children list vectors integer values. dat_long Long format data frame , , prob, vals columns. ... additional arguments","code":""},{"path":"/reference/define_model.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define decision tree model — define_model","text":"transmat, tree_dat dat_long class object","code":""},{"path":"/reference/define_model.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define decision tree model — define_model","text":"","code":"define_model(transmat =               list(prob = matrix(data=c(NA, 0.5, 0.5), nrow = 1),                    vals = matrix(data=c(NA, 1, 2), nrow = 1)               )) #> $prob #>      [,1] [,2] [,3] #> [1,]   NA  0.5  0.5 #>  #> $vals #>      [,1] [,2] [,3] #> [1,]   NA    1    2 #>  #> attr(,\"class\") #> [1] \"transmat\" \"list\"      define_model(tree_dat =               list(child = list(\"1\" = c(2, 3),                                 \"2\" = NULL,                                 \"3\" = NULL),                    dat = data.frame(node = 1:3,                                     prob = c(NA, 0.5, 0.5),                                     vals = c(0, 1, 2))               )) #> $child #> $child$`1` #> [1] 2 3 #>  #> $child$`2` #> NULL #>  #> $child$`3` #> NULL #>  #>  #> $dat #>   node prob vals #> 1    1   NA    0 #> 2    2  0.5    1 #> 3    3  0.5    2 #>  #> attr(,\"class\") #> [1] \"tree_dat\" \"list\"      define_model(dat_long = data.frame(from = c(NA, 1, 1),                                    to = 1:3,                                    prob = c(NA, 0.5, 0.5),                                    vals = c(0, 1, 2))) #>   from to prob vals #> 1   NA  1   NA    0 #> 2    1  2  0.5    1 #> 3    1  3  0.5    2 #> 4    2  4   NA    0 #> 5    3  4   NA    0"},{"path":"/reference/fill_complementary_probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Fill Complementary Probabilities — fill_complementary_probs","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"one pair branches assigned probability event probability filled-afterwards. good specify fewer input values sampling probabilities know complementary probability.","code":""},{"path":"/reference/fill_complementary_probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"","code":"fill_complementary_probs(dat_long)"},{"path":"/reference/fill_complementary_probs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"dat_long Long format data frame , , prob, vals columns.","code":""},{"path":"/reference/fill_complementary_probs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"Long format tree object","code":""},{"path":"/reference/fill_complementary_probs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"works binary trees one n missing.","code":""},{"path":"/reference/fill_complementary_probs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fill Complementary Probabilities — fill_complementary_probs","text":"","code":"dat <- tibble::tribble(~from, ~to, ~prob, ~vals,                        1,  2,  NA,    10,                        1,  3,  0.8,    1,                        2,  4,  0.2,   10,                        2,  5,  NA,     1,                        3,  6,  0.2,   10,                        3,  7,  0.8,    1) fill_complementary_probs(dat) #> # A tibble: 6 × 4 #>    from    to  prob  vals #>   <dbl> <dbl> <dbl> <dbl> #> 1     1     2   0.2    10 #> 2     1     3   0.8     1 #> 3     2     4   0.2    10 #> 4     2     5   0.8     1 #> 5     3     6   0.2    10 #> 6     3     7   0.8     1"},{"path":"/reference/insert_to_transmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Insert to transition matrix — insert_to_transmat","title":"Insert to transition matrix — insert_to_transmat","text":"Insert values transition matrix long array , values Insert values cost matrix long array , values Insert values probability matrix long array , values","code":""},{"path":"/reference/insert_to_transmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Insert to transition matrix — insert_to_transmat","text":"","code":"insert_to_transmat(dat, mat)  insert_to_costmat(dat, mat)  insert_to_probmat(dat, mat)"},{"path":"/reference/insert_to_transmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Insert to transition matrix — insert_to_transmat","text":"dat Long --vals array. Either cost prob. mat Transition matrix","code":""},{"path":"/reference/insert_to_transmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Insert to transition matrix — insert_to_transmat","text":"matrix transition matrix Probability matrix","code":""},{"path":"/reference/insert_to_transmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Insert to transition matrix — insert_to_transmat","text":"","code":"#insert_to_transmat(dat, mat)"},{"path":"/reference/is_prob_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Is object a transition probability matrix? — is_prob_matrix","title":"Is object a transition probability matrix? — is_prob_matrix","text":"object transition probability matrix?","code":""},{"path":"/reference/is_prob_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is object a transition probability matrix? — is_prob_matrix","text":"","code":"is_prob_matrix(probs, dp = 5)"},{"path":"/reference/is_prob_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is object a transition probability matrix? — is_prob_matrix","text":"probs matrix transition probabilities dp Decimal places; Tolerance equivalence","code":""},{"path":"/reference/is_prob_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is object a transition probability matrix? — is_prob_matrix","text":"logical","code":""},{"path":"/reference/is_prob_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is object a transition probability matrix? — is_prob_matrix","text":"","code":"if (FALSE) { probs <- matrix(c(1,0,0,1), nrow = 2) is_prob_matrix(probs)  probs <- matrix(c(2,0,-1,1), nrow = 2) assert_that(is_prob_matrix(probs)) }"},{"path":"/reference/long_to_transmat.html","id":null,"dir":"Reference","previous_headings":"","what":"Long format to transition matrix — long_to_transmat","title":"Long format to transition matrix — long_to_transmat","text":"Long format transition matrix","code":""},{"path":"/reference/long_to_transmat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Long format to transition matrix — long_to_transmat","text":"","code":"long_to_transmat(dat, val_col = \"prob\")"},{"path":"/reference/long_to_transmat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Long format to transition matrix — long_to_transmat","text":"dat array , , prob, vals val_col Name value column; default prob (string)","code":""},{"path":"/reference/long_to_transmat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Long format to transition matrix — long_to_transmat","text":"Transition matrix","code":""},{"path":"/reference/long_to_transmat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Long format to transition matrix — long_to_transmat","text":"","code":"dat <- data.frame(from = c(NA,1, 1),                   to = c(1, 2, 3),                   prob = c(NA, 0.5, 0.5),                   vals = c(0, 1, 2)) long_to_transmat(dat) #>    1   2   3 #> 1 NA 0.5 0.5 #> 2 NA  NA  NA #> 3 NA  NA  NA"},{"path":"/reference/match_branchlabel_to_prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Match branch label to probabilities — match_branchlabel_to_prob","title":"Match branch label to probabilities — match_branchlabel_to_prob","text":"look-table labels values. can join values nodes/edges via labels.","code":""},{"path":"/reference/match_branchlabel_to_prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match branch label to probabilities — match_branchlabel_to_prob","text":"","code":"match_branchlabel_to_prob(probs_names, branch_probs_long)"},{"path":"/reference/match_branchlabel_to_prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match branch label to probabilities — match_branchlabel_to_prob","text":"probs_names label-probability look-branch_probs_long long format tree object labels","code":""},{"path":"/reference/match_branchlabel_to_prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match branch label to probabilities — match_branchlabel_to_prob","text":"dataframe","code":""},{"path":[]},{"path":"/reference/match_branchlabel_to_prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match branch label to probabilities — match_branchlabel_to_prob","text":"","code":"probs_long <-   tibble::tribble(~from, ~to, ~name,                   1, 2, \"pos\",                   1, 3, \"neg\") probs_names <-   tibble::tribble(~prob, ~name,                   0.4, \"pos\",                   0.6, \"neg\")  match_branchlabel_to_prob(probs_names, probs_long) #> # A tibble: 2 × 4 #>    prob name   from    to #>   <dbl> <chr> <dbl> <dbl> #> 1   0.4 pos       1     2 #> 2   0.6 neg       1     3"},{"path":"/reference/match_branch_to_label.html","id":null,"dir":"Reference","previous_headings":"","what":"Match branch to label — match_branch_to_label","title":"Match branch to label — match_branch_to_label","text":"Assume node labels may non-unique. assign labels joining lookup table labels edges tree object, case long array format.","code":""},{"path":"/reference/match_branch_to_label.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Match branch to label — match_branch_to_label","text":"","code":"match_branch_to_label(probs_long, probs_from_to_lookup)"},{"path":"/reference/match_branch_to_label.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Match branch to label — match_branch_to_label","text":"probs_long Long format array tree object probs_from_to_lookup edge-label look-table","code":""},{"path":"/reference/match_branch_to_label.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Match branch to label — match_branch_to_label","text":"dataframe","code":""},{"path":"/reference/match_branch_to_label.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Match branch to label — match_branch_to_label","text":"Separating tree structure labelling means can reuse tree different labels e.g. another test treatment","code":""},{"path":[]},{"path":"/reference/match_branch_to_label.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Match branch to label — match_branch_to_label","text":"","code":"probs_long <-   tibble::tribble(~from, ~to, ~prob,                   1, 2, 0.5,                   1, 3, 0.5) pname_from_to <-   tibble::tribble(~from, ~to, ~name,                   1, 2, \"pos\",                   1, 3, \"neg\")  match_branch_to_label(probs_long, pname_from_to) #>   from to name #> 1    1  2  pos #> 2    1  3  neg"},{"path":"/reference/new_models.html","id":null,"dir":"Reference","previous_headings":"","what":"New Model Constructors — new_models","title":"New Model Constructors — new_models","text":"New Model Constructors New transition matrix New tree data New long data","code":""},{"path":"/reference/new_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New Model Constructors — new_models","text":"","code":"new_transmat(transmat, ...)  new_tree_dat(tree_dat, ...)  new_dat_long(dat_long, fill_edges = TRUE, fill_probs = FALSE)"},{"path":"/reference/new_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"New Model Constructors — new_models","text":"transmat Transition probability matrix. Rows nodes columns nodes. ... Additional arguments tree_dat Hierarchical tree structure parents children list vectors integer values. dat_long Long format data frame , , prob, vals columns. fill_edges need missing edges connect sink state; logical fill_probs Fill missing probabilities; logical","code":""},{"path":"/reference/probs.html","id":null,"dir":"Reference","previous_headings":"","what":"Probabilities in transition matrix format — probs","title":"Probabilities in transition matrix format — probs","text":"Probabilities transition matrix format","code":""},{"path":"/reference/probs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Probabilities in transition matrix format — probs","text":"","code":"probs"},{"path":"/reference/probs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Probabilities in transition matrix format — probs","text":"3--7 matrix rows state columns state","code":""},{"path":"/reference/run_cedectree.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Cost-effectiveness Decision Tree — run_cedectree","title":"Run Cost-effectiveness Decision Tree — run_cedectree","text":"Wrapper `dectree()` costs health value.","code":""},{"path":"/reference/run_cedectree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Cost-effectiveness Decision Tree — run_cedectree","text":"","code":"run_cedectree(   dat_long,   label_probs_distns = NULL,   label_costs_distns = NULL,   label_health_distns = NULL,   state_list = NULL,   n = 100 )"},{"path":"/reference/run_cedectree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Cost-effectiveness Decision Tree — run_cedectree","text":"dat_long Long format data frame , , prob, vals columns. label_probs_distns Probability distribution names label_costs_distns Cost distribution names label_health_distns Health value distribution names state_list State list sets, usually terminal nodes n Number PSA samples; default 100","code":""},{"path":"/reference/run_cedectree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Cost-effectiveness Decision Tree — run_cedectree","text":"List cost, health `dectree()` output","code":""},{"path":[]},{"path":"/reference/terminal_pop.html","id":null,"dir":"Reference","previous_headings":"","what":"Terminal Leaf Node Populations — terminal_pop","title":"Terminal Leaf Node Populations — terminal_pop","text":"Joint probabilities sets nodes. useful provide starting state populations Markov model.","code":""},{"path":"/reference/terminal_pop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Terminal Leaf Node Populations — terminal_pop","text":"","code":"terminal_pop(model, state_list)"},{"path":"/reference/terminal_pop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Terminal Leaf Node Populations — terminal_pop","text":"model dat_long class state_list Groups (usually) terminal nodes; List vectors","code":""},{"path":"/reference/terminal_pop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Terminal Leaf Node Populations — terminal_pop","text":"Vector probabilities","code":""},{"path":"/reference/terminal_pop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Terminal Leaf Node Populations — terminal_pop","text":"","code":"tree_dat <-  tibble::tribble(    ~from, ~to, ~vals, ~prob,    1,  2,   10,   0.7,    1,  3,   NA,   0.3,    2,  4,  100,   0.1,    2,  5,   NA,   0.9,    3,  6,  100,   0.9,    3,  7,   NA,   0.1)  term_pop <-   define_model(dat_long = tree_dat) |>   terminal_pop(state_list = c(4,5,6,7))  sum(unlist(term_pop)) #> [1] 1"},{"path":"/reference/transmat_to_child_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Create tree children list from transition matrix — transmat_to_child_list","title":"Create tree children list from transition matrix — transmat_to_child_list","text":"Create tree children list parents transition matrix.","code":""},{"path":"/reference/transmat_to_child_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create tree children list from transition matrix — transmat_to_child_list","text":"","code":"transmat_to_child_list(transmat)"},{"path":"/reference/transmat_to_child_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create tree children list from transition matrix — transmat_to_child_list","text":"transmat Transition probability matrix. Rows nodes columns nodes.","code":""},{"path":"/reference/transmat_to_child_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create tree children list from transition matrix — transmat_to_child_list","text":"list","code":""},{"path":"/reference/transmat_to_child_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create tree children list from transition matrix — transmat_to_child_list","text":"","code":"transmat <-   list(prob = matrix(data = c(NA, 0.5, 0.5), nrow = 1),        vals = matrix(data = c(NA, 1, 2), nrow = 1)        ) transmat_to_child_list(transmat$prob) #> $`1` #> [1] 2 3 #>  #> $`2` #> integer(0) #>  #> $`3` #> integer(0) #>"},{"path":"/reference/transmat_to_long.html","id":null,"dir":"Reference","previous_headings":"","what":"Transition matrix to long format — transmat_to_long","title":"Transition matrix to long format — transmat_to_long","text":"Transition matrix long format","code":""},{"path":"/reference/transmat_to_long.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transition matrix to long format — transmat_to_long","text":"","code":"transmat_to_long(probs)"},{"path":"/reference/transmat_to_long.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transition matrix to long format — transmat_to_long","text":"probs Probability transition matrix","code":""},{"path":"/reference/transmat_to_long.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transition matrix to long format — transmat_to_long","text":"array , , prob","code":""},{"path":"/reference/transmat_to_long.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transition matrix to long format — transmat_to_long","text":"","code":"tree <- list(    prob = matrix(data = c(NA, 0.5, 0.5), nrow = 1),    vals = matrix(data = c(NA, 1, 2), nrow = 1))  transmat_to_long(tree$prob) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #>   from to prob #> 2    1  2  0.5 #> 3    1  3  0.5"},{"path":"/reference/trans_binarytree.html","id":null,"dir":"Reference","previous_headings":"","what":"Transition matrix to binary tree — trans_binarytree","title":"Transition matrix to binary tree — trans_binarytree","text":"adapted mstate::trans.illness. Create complete binary tree transition matrix.","code":""},{"path":"/reference/trans_binarytree.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transition matrix to binary tree — trans_binarytree","text":"","code":"trans_binarytree(names, depth = 2)"},{"path":"/reference/trans_binarytree.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transition matrix to binary tree — trans_binarytree","text":"names Node names depth Depth tree; integer","code":""},{"path":"/reference/trans_binarytree.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transition matrix to binary tree — trans_binarytree","text":"Matrix TRUE FALSE","code":""},{"path":"/reference/trans_binarytree.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transition matrix to binary tree — trans_binarytree","text":"","code":"trans_binarytree(c(\"A\", \"B\"), depth = 2) #>     to #> from  1  2  3  4  5 #>    1 NA  1  2 NA NA #>    2 NA NA NA  3  4"},{"path":"/reference/validation.html","id":null,"dir":"Reference","previous_headings":"","what":"New Model Validation — validation","title":"New Model Validation — validation","text":"New Model Validation","code":""},{"path":"/reference/validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"New Model Validation — validation","text":"","code":"validate_transmat(transmat)  validate_tree_dat(tree_dat)  validate_dat_long(dat_long)"},{"path":"/reference/validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"New Model Validation — validation","text":"transmat Transition probability matrix. Rows nodes columns nodes. tree_dat Hierarchical tree structure parents children list vectors integer values. dat_long Long format data frame , , prob, vals columns.","code":""},{"path":"/reference/validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"New Model Validation — validation","text":"transmat tree_dat dat_long","code":""},{"path":"/news/index.html","id":"cedecisiontree-010","dir":"Changelog","previous_headings":"","what":"CEdecisiontree 0.1.0","title":"CEdecisiontree 0.1.0","text":"Added NEWS.md file track changes package. heemod comparison dd44cfa scenario sensitivity analysis 84a2079 build tree 5fdbbb6 component decision tree 9d9b55a Recursive version expected value calculation e2ec1bf pkgdown site 7a0d983 Generalise binary tree number children 65dfa30","code":""}]
